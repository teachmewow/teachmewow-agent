"""
Database observer for persisting messages during streaming.
"""

import json
import uuid
from datetime import datetime, timezone

from langchain_core.messages import AIMessage, BaseMessage, ToolMessage

from app.application.agent.state_schema import StreamEvent
from app.domain import Message, MessageRole, ToolCall
from app.domain.repositories import MessageRepository


class DatabaseObserver:
    """
    Observer that persists AI messages to the database.

    This observer listens to stream events and saves the AI response
    to the database when the stream completes.
    """

    def __init__(
        self,
        message_repository: MessageRepository,
        thread_id: str,
    ):
        """
        Initialize the database observer.

        Args:
            message_repository: Repository for message persistence
            thread_id: ID of the conversation thread
        """
        self.message_repository = message_repository
        self.thread_id = thread_id

    async def on_event(self, event: StreamEvent) -> None:
        """
        Called when a stream event is processed.

        Persists tool results as they happen to ensure tool messages
        are available in history for subsequent LLM calls.

        Args:
            event: The stream event that was processed
        """
        if event.event != "on_tool_end":
            return

        tool_call_id = event.run_id or ""
        if not tool_call_id:
            return

        output = event.data.get("output")
        content = json.dumps(output) if isinstance(output, (dict, list)) else str(output)

        tool_message = Message(
            id=f"tool_{tool_call_id}",
            thread_id=self.thread_id,
            role=MessageRole.TOOL,
            content=content,
            tool_call_id=tool_call_id,
            tool_result=content,
        )
        await self.message_repository.save(tool_message)

    async def on_node_complete(self, node: str, messages: list[BaseMessage]) -> None:
        """
        Called when a node completes and produces new messages.

        Persists AI and tool messages generated by the graph.

        Args:
            node: The node name that completed
            messages: New messages produced by the node
        """
        for message in messages:
            domain_message = self._convert_message(message)
            if domain_message is not None:
                await self.message_repository.save(domain_message)

    async def on_stream_complete(self, full_response: str) -> None:
        """
        Called when the stream is complete.

        Saves the AI response to the database.

        Args:
            full_response: The complete accumulated response text
        """
        # Persistence now happens on node completion.
        # We keep this method as a no-op for future extensions.
        return

    async def on_error(self, error: Exception) -> None:
        """
        Called when an error occurs during streaming.

        Could be extended to log errors or save partial responses.

        Args:
            error: The exception that occurred
        """
        # Could log the error or save partial response
        pass

    def _convert_message(self, message: BaseMessage) -> Message | None:
        """
        Convert a LangChain BaseMessage to a domain Message.

        Args:
            message: LangChain message instance

        Returns:
            Domain Message or None if not supported
        """
        if isinstance(message, AIMessage):
            return self._convert_ai_message(message)

        if isinstance(message, ToolMessage):
            return self._convert_tool_message(message)

        return None

    def _convert_ai_message(self, message: AIMessage) -> Message:
        """Convert AIMessage to domain Message (including tool calls)."""
        tool_calls = None
        if message.tool_calls:
            tool_calls = [
                ToolCall(
                    id=tool_call.get("id", ""),
                    name=tool_call.get("name", ""),
                    arguments=json.dumps(tool_call.get("args", {})),
                )
                for tool_call in message.tool_calls
            ]

        return Message(
            id=str(uuid.uuid4()),
            thread_id=self.thread_id,
            role=MessageRole.AI,
            content=message.content or "",
            timestamp=datetime.now(timezone.utc),
            tool_calls=tool_calls,
        )

    def _convert_tool_message(self, message: ToolMessage) -> Message:
        """Convert ToolMessage to domain Message."""
        return Message(
            id=str(uuid.uuid4()),
            thread_id=self.thread_id,
            role=MessageRole.TOOL,
            content=message.content or "",
            timestamp=datetime.now(timezone.utc),
            tool_call_id=message.tool_call_id,
            tool_result=message.content or "",
        )
